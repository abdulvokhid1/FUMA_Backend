import {
  BadRequestException,
  Injectable,
  NotFoundException,
  UnauthorizedException,
} from '@nestjs/common';
import { PrismaService } from '../../prisma/prisma.service';
import * as bcrypt from 'bcrypt';
import { JwtService } from '@nestjs/jwt';
import {
  MembershipPlan,
  PaymentMethod,
  SubmissionStatus,
  User as PrismaUser,
  User,
} from '@prisma/client';
import { RegisterDto, SubmitMembershipDto } from './dto/user.dto';
import { getPlanAccessMap } from '../utils/plan-access.util';
import * as crypto from 'crypto';
import { AuthErrorCode } from '@/common/errors/auth-error-code';

const THIRTY_DAYS_MS = 30 * 24 * 60 * 60 * 1000;

@Injectable()
export class UserService {
  constructor(
    private readonly prisma: PrismaService,
    private readonly jwt: JwtService,
  ) {}

  async register(dto: RegisterDto) {
    const existing = await this.prisma.user.findUnique({
      where: { email: dto.email },
    });
    if (existing) throw new BadRequestException('Email already in use');

    const hash = await bcrypt.hash(dto.password, 10);

    const user = await this.prisma.user.create({
      data: {
        email: dto.email,
        password: hash,
        name: dto.name,
        phone: dto.phone,
        isApproved: false,
        isPayed: false,
        paymentProofUrl: null,
        accessExpiresAt: null,
        notifications: {
          create: {
            type: 'USER_REGISTERED',
            message: `üÜï New user registered: ${dto.email}`,
          },
        },
      },
      include: { notifications: true }, // optional
    });

    return { message: 'Registration successful', userId: user.id };
  }

  async login(dto: { email: string; password: string }) {
    const user = await this.prisma.user.findUnique({
      where: { email: dto.email },
    });

    if (!user) {
      throw new BadRequestException({
        statusCode: 400,
        message: 'Email is not registered',
        error: 'Bad Request',
        errorCode: AuthErrorCode.EMAIL_NOT_REGISTERED,
      });
    }

    const valid = await bcrypt.compare(dto.password, user.password);
    if (!valid) {
      throw new BadRequestException({
        statusCode: 400,
        message: 'Password is wrong',
        error: 'Bad Request',
        errorCode: AuthErrorCode.PASSWORD_INCORRECT,
      });
    }

    const latestApproved = await this.prisma.paymentSubmission.findFirst({
      where: { userId: user.id, status: 'APPROVED' },
      orderBy: { createdAt: 'desc' },
      select: { plan: true },
    });

    const now = new Date();
    const isExpired =
      user.accessExpiresAt !== null &&
      user.accessExpiresAt.getTime() < now.getTime();

    if (isExpired) {
      await this.prisma.user.update({
        where: { id: user.id },
        data: {
          isApproved: false,
          isPayed: false,
        },
      });
    }

    const payload = {
      sub: user.id,
      email: user.email,
      plan: latestApproved?.plan ?? 'NOMEMBERSHIP',
    };

    // ‚úÖ 1h access token
    const accessToken = await this.jwt.signAsync(payload, {
      expiresIn: '1h',
    });

    // ‚úÖ 7d refresh token
    const refreshToken = await this.jwt.signAsync(payload, {
      expiresIn: '7d',
    });

    // ‚úÖ Hash and store refresh token
    const hashedRefresh = await bcrypt.hash(refreshToken, 10);
    await this.prisma.user.update({
      where: { id: user.id },
      data: { hashedRefreshToken: hashedRefresh },
    });

    return {
      access_token: accessToken,
      refresh_token: refreshToken,
    };
  }

  async forgotPassword(email: string) {
    const user = await this.prisma.user.findUnique({ where: { email } });
    if (!user) {
      throw new NotFoundException('No user found with that email.');
    }

    const token = crypto.randomBytes(32).toString('hex');
    const hashedToken = await bcrypt.hash(token, 10);
    const expiry = new Date(Date.now() + 1000 * 60 * 15); // 15 mins

    await this.prisma.user.update({
      where: { id: user.id },
      data: {
        resetToken: hashedToken,
        resetTokenExpiry: expiry,
      },
    });

    // TODO: Send token via email. For now, return it for development.
    return { message: 'Reset token generated', resetToken: token };
  }

  async resetPassword(token: string, newPassword: string) {
    const users = await this.prisma.user.findMany({
      where: {
        resetToken: { not: null },
        resetTokenExpiry: { gte: new Date() },
      },
    });

    let matchedUser: User | null = null;
    for (const user of users) {
      const isMatch = await bcrypt.compare(token, user.resetToken!);
      if (isMatch) {
        matchedUser = user;
        break;
      }
    }

    if (!matchedUser) {
      throw new UnauthorizedException('Invalid or expired reset token.');
    }

    const newHashed = await bcrypt.hash(newPassword, 10);

    await this.prisma.user.update({
      where: { id: matchedUser.id },
      data: {
        password: newHashed,
        resetToken: null,
        resetTokenExpiry: null,
      },
    });

    return { message: 'Password has been reset successfully.' };
  }
  async refreshTokens(refreshToken: string) {
    if (!refreshToken) {
      throw new UnauthorizedException('Î¶¨ÌîÑÎ†àÏãú ÌÜ†ÌÅ∞Ïù¥ ÏóÜÏäµÎãàÎã§.');
    }

    try {
      const payload = await this.jwt.verifyAsync(refreshToken);
      const user = await this.prisma.user.findUnique({
        where: { id: payload.sub },
      });

      if (!user || !user.hashedRefreshToken) {
        throw new UnauthorizedException('Ïú†Ï†ÄÍ∞Ä ÏóÜÍ±∞ÎÇò ÌÜ†ÌÅ∞Ïù¥ ÏóÜÏäµÎãàÎã§.');
      }

      const isValid = await bcrypt.compare(
        refreshToken,
        user.hashedRefreshToken,
      );
      if (!isValid) {
        throw new UnauthorizedException('Î¶¨ÌîÑÎ†àÏãú ÌÜ†ÌÅ∞Ïù¥ Ïú†Ìö®ÌïòÏßÄ ÏïäÏäµÎãàÎã§.');
      }

      // ‚úÖ Issue new access token
      const latestApproved = await this.prisma.paymentSubmission.findFirst({
        where: { userId: user.id, status: 'APPROVED' },
        orderBy: { createdAt: 'desc' },
        select: { plan: true },
      });

      const newAccessToken = await this.jwt.signAsync(
        {
          sub: user.id,
          email: user.email,
          plan: latestApproved?.plan ?? 'NOMEMBERSHIP',
        },
        { expiresIn: '1h' },
      );

      return { access_token: newAccessToken };
    } catch (err) {
      throw new UnauthorizedException(
        'Î¶¨ÌîÑÎ†àÏãú ÌÜ†ÌÅ∞Ïù¥ ÎßåÎ£åÎêòÏóàÍ±∞ÎÇò ÏûòÎ™ªÎêòÏóàÏäµÎãàÎã§.',
      );
    }
  }

  async logout(userId: number) {
    await this.prisma.user.update({
      where: { id: userId },
      data: { hashedRefreshToken: null },
    });
    return { message: 'Î°úÍ∑∏ÏïÑÏõÉ ÏôÑÎ£å' };
  }

  async getMe(userId: number) {
    return this.buildMypageEntitlements(userId);
  }

  /** Latest submission for gating the UI */
  async latestSubmission(userId: number) {
    const latest = await this.prisma.paymentSubmission.findFirst({
      where: { userId },
      orderBy: { createdAt: 'desc' },
      select: { id: true, status: true, plan: true, createdAt: true },
    });
    let statusMessage = '‚ùå Í≤∞Ï†ú Ï†úÏ∂ú ÎÇ¥Ïó≠Ïù¥ ÏóÜÏäµÎãàÎã§.';
    if (latest?.status === 'PENDING') {
      statusMessage = '‚è≥ Í≤∞Ï†ú ÏäπÏù∏ ÎåÄÍ∏∞ Ï§ëÏûÖÎãàÎã§.';
    } else if (latest?.status === 'APPROVED') {
      statusMessage = '‚úÖ ÏäπÏù∏ ÏôÑÎ£åÎêòÏóàÏäµÎãàÎã§.';
    } else if (latest?.status === 'REJECTED') {
      statusMessage = '‚ùå Í≤∞Ï†úÍ∞Ä Í±∞Ï†àÎêòÏóàÏäµÎãàÎã§. Îã§Ïãú Ï†úÏ∂úÌï¥ Ï£ºÏÑ∏Ïöî.';
    }

    return {
      latest,
      statusMessage,
    };
  }

  /** Submit membership (atomic, race-safe) */
  async submitMembership(
    userId: number,
    dto: SubmitMembershipDto,
    file: Express.Multer.File,
  ) {
    // 1) Validate file
    if (!file)
      throw new BadRequestException('Í≤∞Ï†ú Ï¶ùÎπô Ïù¥ÎØ∏ÏßÄÎ•º ÏóÖÎ°úÎìúÌï¥Ï£ºÏÑ∏Ïöî.');
    const filePath = `/uploads/payment_proofs/${file.filename}`;

    // 2) Normalize and fetch plan meta
    const planName = String(dto.membershipPlan).toUpperCase() as MembershipPlan;
    const method = String(dto.paymentMethod).toUpperCase() as PaymentMethod;

    const planMeta = await this.prisma.membershipPlanMeta.findUnique({
      where: { name: planName },
    });

    if (!planMeta || !planMeta.isActive) {
      throw new BadRequestException(
        'ÏÑ†ÌÉùÌïú ÌîåÎûúÏù¥ Ï°¥Ïû¨ÌïòÏßÄ ÏïäÍ±∞ÎÇò ÎπÑÌôúÏÑ±ÌôîÎêòÏóàÏäµÎãàÎã§.',
      );
    }

    // 3) Ensure user exists
    const user = await this.prisma.user.findUnique({ where: { id: userId } });
    if (!user) throw new NotFoundException('Ïú†Ï†ÄÎ•º Ï∞æÏùÑ Ïàò ÏóÜÏäµÎãàÎã§.');

    // 4) Atomic transaction
    await this.prisma.$transaction(async (tx) => {
      // Guard: single pending submission
      const existingPending = await tx.paymentSubmission.findFirst({
        where: { userId, status: SubmissionStatus.PENDING },
        select: { id: true },
      });
      if (existingPending) {
        throw new BadRequestException('Ïù¥ÎØ∏ Í≤ÄÌÜ† Ï§ëÏù∏ Í≤∞Ï†ú Ï†úÏ∂úÏù¥ ÏûàÏäµÎãàÎã§.');
      }

      // Create submission
      await tx.paymentSubmission.create({
        data: {
          userId,
          plan: planName, // Prisma enum
          paymentMethod: method, // Prisma enum
          filePath,
          fileOriginalName: file.originalname,
          status: SubmissionStatus.PENDING,
        },
      });

      // Update user snapshot for UI (no expiry yet; set on approval)
      await tx.user.update({
        where: { id: userId },
        data: {
          paymentMethod: method,
          paymentProofUrl: filePath,
          isApproved: false,
          isPayed: false,
        },
      });

      // Optional: notify admins (your existing Notification create)
      await tx.notification.create({
        data: {
          userId,
          type: 'NEW_PAYMENT_PROOF',
          message: `üì© ${user.name || user.email}ÎãòÏù¥ '${planName}' ÌîåÎûú Í≤∞Ï†úÎ•º Ï†úÏ∂úÌñàÏäµÎãàÎã§.`,
          plan: planName,
          isRead: false,
          isApproved: false,
          isPayed: false,
        },
      });
    });

    return { message: 'Í≤∞Ï†úÍ∞Ä Ï†úÏ∂úÎêòÏóàÏäµÎãàÎã§. Í¥ÄÎ¶¨Ïûê ÏäπÏù∏ ÎåÄÍ∏∞ Ï§ëÏûÖÎãàÎã§.' };
  }

  /** Build Entitlements aligned with frontend shape */
  async buildMypageEntitlements(userId: number) {
    const user = await this.prisma.user.findUnique({
      where: { id: userId },
      select: {
        id: true,
        email: true,
        name: true,
        phone: true,
        paymentProofUrl: true,
        createdAt: true,
        updatedAt: true,
        isApproved: true,
        isPayed: true,
        accessExpiresAt: true,
      },
    });

    if (!user) throw new NotFoundException('User not found');

    // 1. Get latest approved plan
    const latestApproved = await this.prisma.paymentSubmission.findFirst({
      where: { userId, status: 'APPROVED' },
      orderBy: { createdAt: 'desc' },
      select: { plan: true },
    });

    const planName = latestApproved?.plan ?? 'NOMEMBERSHIP';

    // 2. Fetch plan metadata
    const planMeta = latestApproved?.plan
      ? await this.prisma.membershipPlanMeta.findUnique({
          where: { name: latestApproved.plan },
        })
      : null;

    // 3. Determine access status
    const now = new Date();
    const isExpired =
      user.accessExpiresAt !== null &&
      user.accessExpiresAt.getTime() < now.getTime();

    const isActive = !!user.isApproved && !isExpired;

    // 4. Access flags using centralized utility
    const metaFeatures = (planMeta?.features as Record<string, any>) ?? {};
    const access = getPlanAccessMap(metaFeatures, isActive);

    // 5. Quotas
    const quotas: Record<string, any> = {};
    const consultLimitFromMeta = Number.isFinite(metaFeatures.CONSULT_LIMIT)
      ? Number(metaFeatures.CONSULT_LIMIT)
      : undefined;

    if (consultLimitFromMeta !== undefined) {
      quotas.CONSULT_1ON1 = { monthlyLimit: consultLimitFromMeta, used: 0 };
    } else {
      // fallback by plan name
      if (planName === 'VIP')
        quotas.CONSULT_1ON1 = {
          monthlyLimit: Number.POSITIVE_INFINITY,
          used: 0,
        };
      else if (planName === 'PRO')
        quotas.CONSULT_1ON1 = { monthlyLimit: 4, used: 0 };
      else if (planName === 'BASIC')
        quotas.CONSULT_1ON1 = { monthlyLimit: 2, used: 0 };
    }
    let statusMessage = '‚úÖ Access granted';
    if (!user.isApproved) {
      statusMessage = '‚ùóÔ∏èÍ¥ÄÎ¶¨ÏûêÏùò ÏäπÏù∏ÏùÑ Í∏∞Îã§Î¶¨Í≥† ÏûàÏäµÎãàÎã§.';
    } else if (isExpired) {
      statusMessage = '‚õîÔ∏è Ï†ëÍ∑º Í∂åÌïúÏù¥ ÎßåÎ£åÎêòÏóàÏäµÎãàÎã§. ÌîåÎûúÏùÑ Í∞±Ïã†Ìï¥ Ï£ºÏÑ∏Ïöî.';
    }

    // 6. Final return
    return {
      id: user.id,
      email: user.email,
      name: user.name,
      phone: user.phone,
      paymentProofUrl: user.paymentProofUrl ?? null,
      createdAt: user.createdAt.toISOString(),
      updatedAt: user.updatedAt.toISOString(),
      plan: planName,
      isApproved: !!user.isApproved,
      isPayed: !!user.isPayed,
      accessExpiresAt: user.accessExpiresAt?.toISOString() ?? null,
      isExpired,
      isActive,
      access,
      quotas,
      statusMessage,
    };
  }

  async getActivePlans() {
    const plans = await this.prisma.membershipPlanMeta.findMany({
      where: { isActive: true },
      orderBy: { price: 'asc' },
    });

    return { plans };
  }

  async getAccessOnly(userId: number) {
    const user = await this.prisma.user.findUnique({
      where: { id: userId },
      select: {
        isApproved: true,
        accessExpiresAt: true,
      },
    });
    if (!user) throw new NotFoundException('User not found');

    const latestApproved = await this.prisma.paymentSubmission.findFirst({
      where: { userId, status: 'APPROVED' },
      orderBy: { createdAt: 'desc' },
      select: { plan: true },
    });

    const planName = latestApproved?.plan ?? 'NOMEMBERSHIP';

    const planMeta = latestApproved?.plan
      ? await this.prisma.membershipPlanMeta.findUnique({
          where: { name: latestApproved.plan },
        })
      : null;

    const now = new Date();
    const isExpired =
      user.accessExpiresAt !== null &&
      user.accessExpiresAt.getTime() < now.getTime();

    const isActive = !!user.isApproved && !isExpired;

    const metaFeatures = (planMeta?.features as Record<string, any>) ?? {};
    const access = getPlanAccessMap(metaFeatures, isActive);

    return {
      plan: planName,
      isActive,
      isExpired,
      access,
    };
  }
}
